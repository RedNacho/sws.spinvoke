**THE (POSSIBLY IMAGINARY) PROBLEM!**

It's all a bit vague at the moment... but the idea is this.

If you're a C# programmer and you want to call a native function, you can do one of two things:

1. Use DllImport and extern, if you know the library and function names at design time.  Personally I prefer to steer clear of this, as the library is just an arbitrary file, and I don't want to hard-code where it is.

2. Define a delegate type to match the function signature, load the library dynamically and get hold of the function pointer (e.g. using Kernel32 on Windows), then do some funky stuff with Marshal to create a delegate instance.

*Edit: You can also try some other things, like wrapping up the native code with some more friendly intermediary such as managed C++, but some of us prefer to be home by dinner time.*

It occurred to me the other day that both of these approaches are quite annoying when it comes to dependency injection.

In the first case, your methods must be static, which sort of makes sense, given that they actually are, but in order to abstract it away behind an interface, you need to repeat all your method definitions in the interface, then create a singleton implementation to wrap the extern calls, etc, etc...

In the second case, you've got a similar mountain of boilerplate.  You've got to define a delegate for each method, then you've got to instantiate the delegates, and then you've got to wrap them up in an implementing class (again, presumably a singleton).  You could probably make life easier for yourself by exposing the delegates directly, since in this scenario you can instantiate them however you want, but all the other developers will hate you.

**THE (POSSIBLY UNNECESSARY) SOLUTION!**

What you really want to be able to do is this:

1. Define all of the native methods for the library just once, in an interface, which you can then mock and stub and generally abuse.

2. Invoke some neat little gizmo with the name of the library to automagically wire up the interface to the real implementation.

I've been trying to write that gizmo.  At the moment it's very much at the PoC stage, but you can bind an interface to a native library as follows:

1. Use Ninject and Castle DynamicProxy.

2. Use Sws.Spinvoke.Ninject.Extensions.

3. Call SpinvokeNinjectExtensionsConfiguration.Configure with a native library loader for your OS (I've only included a Linux implementation but a Windows one is extremely easy - Google LoadLibrary Kernel32) and a proxy generator.  I'm leaving the native library loader up to the client for now, as I can't think of every OS in the universe, and even if I could I wouldn't be able to test my code on all of them.  You can also use your own proxy generator, although I'd recommend using the supplied Castle DynamicProxy implementation unless you have a good reason not to: Sws.Spinvoke.Interception.DynamicProxy.ProxyGenerator.

4. Call Bind<T>().ToNative(libraryName) to bind interface T to a native library which implements the required functions.

**UNTESTED EXAMPLE!**

C functions defined in libNativeCalculator.so:


```
#!c

int add(int x, int y);
int subtract(int x, int y);
int divide(int x, int y);
int multiply(int x, int y);
```


C# interface:


```
#!c#

public interface INativeCalculator
{
    int add(int x, int y);
    int subtract(int x, int y);
    int divide(int x, int y);
    int multiply(int x, int y);
}
```


Wiring:


```
#!c#

SpinvokeNinjectExtensionsConfiguration.Configure(
    new LinuxNativeLibraryLoader(),
    new ProxyGenerator(new Castle.DynamicProxy.ProxyGenerator()));

var kernel = new StandardKernel();
kernel.Bind<INativeCalculator>().ToNative("libNativeCalculator.so");

var nativeCalculator = kernel.Get<INativeCalculator>();

```

Usage:


```
#!c#

var nativeAddResult = nativeCalculator.add(4, 5);
var nativeSubtractResult = nativeCalculator.subtract(11, 2);
var nativeDivideResult = nativeCalculator.divide(18, 2);
var nativeMultiplyResult = nativeCalculator.multiply(3, 3);
```

**A NOTE ABOUT ATTRIBUTES**

I have added a number of attributes which allow the native delegate signature generated by the proxy to be manipulated in various ways, and pre- and post-processing to be applied. These are in Sws.Spinvoke.Interception, and are as follows:

* **NativeDelegateDefinitionOverride**.  Apply this to the delegate method to override various things (all of which are optional as they are inferred by default).  This includes the library name, the function name, the input and output types for the native delegate, the calling convention.  It also allows you specify an explicit delegate type (see below).

* **NativeArgumentDefinitionOverride**.  Abstract; subclasses can be applied to parameters to give finer control.  You can subclass this yourself as required, although the existing classes provide useful examples.

* **NativeReturnDefinitionOverride**.  Abstract; subclasses can be applied to the return value to give finer control.  You can subclass this yourself as required, although the existing classes provide useful examples.

* **DefaultNativeArgumentDefinitionOverride**.  Inherits NativeArgumentDefinitionOverride.  Default parameter settings if none specified.  Applies Convert.ChangeType as necessary to convert the parameter type on the interface to the specified input type.  In the implicit usage, the input type is either unchanged from the interface, or set to the input type specified in the NativeDelegateDefinitionOverride.

* **DefaultNativeReturnDefinitionOverride**.  Inherits NativeReturnDefinitionOverride.  Default return value settings if none specified.  Applies Convert.ChangeType as necessary to convert the expected output type to the return type on the interface.  In the implicit usage, the output type is either unchanged from the interface, or set to the output type specified in the NativeDelegateDefinitionOverride.

* **NativeArgumentAsStringPointer**.  Inherits NativeArgumentDefinitionOverride.  Assigns strings to IntPtr before passing the pointer to the native delegate.

* **NativeReturnsStringPointer**.  Inherits NativeReturnDefinitionOverride.  Expects IntPtr back from the delegate and marshals a string out of it.

* **NativeArgumentAsStructPointer**.  Inherits NativeArgumentDefinitionOverride.  Assigns value types to IntPtr before passing the pointer to the native delegate.

* **NativeReturnsStructPointer**.  Inherits NativeReturnDefinitionOverride.  Expects IntPtr back from the delegate and marshals a value type out of it.

**ANOTHER NOTE ABOUT ATTRIBUTES, AND ABOUT KNOWING WHEN YOU'RE BEATEN**

After experimenting with various techniques, I have come to the conclusion that it's impossible for me to fulfill all of your automatically generated delegate needs all of the time.  I have therefore added an attribute option which allows you to explicitly specify the delegate you want to use, in scenarios where the generated one won't cut it, or you just think it's easier.

Usage:

```
#!c#

// Decorate this with all the shadazzle you know and love - MarshalAs, UnmanagedFunctionPointer, etc.
public delegate int ExplicitAddDelegate(int x, int y);

public interface INativeCalculator
{
    [NativeDelegateDefinitionOverride(ExplicitDelegateType = typeof(ExplicitAddDelegate))]
    int add(int x, int y);
    int subtract(int x, int y);
    int divide(int x, int y);
    int multiply(int x, int y);
}
```