**THE (POSSIBLY IMAGINARY) PROBLEM!**

It's all a bit vague at the moment... but the idea is this.

If you're a C# programmer and you want to call a native function, you can do one of two things:

1. Use DllImport and extern, if you know the library and function names at design time.  Personally I prefer to steer clear of this, as the library is just an arbitrary file, and I don't want to hard-code where it is.

2. Define a delegate type to match the function signature, load the library dynamically and get hold of the function pointer (e.g. using Kernel32 on Windows), then do some funky stuff with Marshal to create a delegate instance.

*Edit: You can also try some other things, like wrapping up the native code with some more friendly intermediary such as managed C++, but some of us prefer to be home by dinner time.*

It occurred to me the other day that both of these approaches are quite annoying when it comes to dependency injection.

In the first case, your methods must be static, which sort of makes sense, given that they actually are, but in order to abstract it away behind an interface, you need to repeat all your method definitions in the interface, then create a singleton implementation to wrap the extern calls, etc, etc...

In the second case, you've got a similar mountain of boilerplate.  You've got to define a delegate for each method, then you've got to instantiate the delegates, and then you've got to wrap them up in an implementing class (again, presumably a singleton).  You could probably make life easier for yourself by exposing the delegates directly, since in this scenario you can instantiate them however you want, but all the other developers will hate you.

**THE (POSSIBLY UNNECESSARY) SOLUTION!**

What you really want to be able to do is this:

1. Define all of the native methods for the library just once, in an interface, which you can then mock and stub and generally abuse.

2. Invoke some neat little gizmo with the name of the library to automagically wire up the interface to the real implementation.

I've been trying to write that gizmo.  At the moment it's very much at the PoC stage, but you can bind an interface to a native library as follows:

1. Use Ninject and Castle DynamicProxy.

2. Use Sws.Spinvoke.Ninject.Extensions.

3. Call SpinvokeNinjectExtensionsConfiguration.Configure with a native library loader for your OS (I've included a Linux implementation as well as less-well-tested implementations for Windows and OSX) and a proxy generator.  I'm leaving the native library loader up to the client for now, as I can't think of every OS in the universe, and even if I could I wouldn't be able to test my code on all of them.  You can also use your own proxy generator, although I'd recommend using the supplied Castle DynamicProxy implementation unless you have a good reason not to: Sws.Spinvoke.Interception.DynamicProxy.ProxyGenerator.

4. Call Bind<T>().ToNative(libraryName) to bind interface T to a native library which implements the required functions.  Optionally, call WithCallingConvention to set the calling convention, and WithNonNativeFallback to specify an implementation which will be called for methods which are not to be mapped to native code (see attributes below).

**UNTESTED EXAMPLE!**

C functions defined in libNativeCalculator.so:


```
#!c

int add(int x, int y);
int subtract(int x, int y);
int divide(int x, int y);
int multiply(int x, int y);
```


C# interface:


```
#!c#

public interface INativeCalculator
{
    int add(int x, int y);
    int subtract(int x, int y);
    int divide(int x, int y);
    int multiply(int x, int y);
}
```


Wiring:


```
#!c#

SpinvokeNinjectExtensionsConfiguration.Configure(
    new LinuxNativeLibraryLoader(),
    new ProxyGenerator(new Castle.DynamicProxy.ProxyGenerator()));

var kernel = new StandardKernel();
kernel.Bind<INativeCalculator>().ToNative("libNativeCalculator.so");

var nativeCalculator = kernel.Get<INativeCalculator>();

```

Usage:


```
#!c#

var nativeAddResult = nativeCalculator.add(4, 5);
var nativeSubtractResult = nativeCalculator.subtract(11, 2);
var nativeDivideResult = nativeCalculator.divide(18, 2);
var nativeMultiplyResult = nativeCalculator.multiply(3, 3);
```

**A NOTE ABOUT ATTRIBUTES**

I have added a number of attributes which allow the native delegate signature generated by the proxy to be manipulated in various ways, and pre- and post-processing to be applied. These are in Sws.Spinvoke.Interception, and are as follows:

* **NativeDelegateDefinitionOverride**.  Apply this to the delegate method to override various things (all of which are optional as they are inferred by default).  This includes the library name, the function name, the input and output types for the native delegate, and the calling convention.  It also allows you specify an explicit delegate type (see below).  You can also set MapNative = false.  This prevents any further processing of the method call and instead passes the invocation to the proxy's target (if you're using the Ninject extensions, you can specify this with WithNonNativeFallback).  If there is no target, the behaviour depends on your proxy implementation (DynamicProxy will throw a NotImplementedException).

* **NativeArgumentDefinitionOverride**.  Abstract; subclasses can be applied to parameters to give finer control.  You can subclass this yourself as required, although the existing classes provide useful examples.

* **NativeReturnDefinitionOverride**.  Abstract; subclasses can be applied to the return value to give finer control.  You can subclass this yourself as required, although the existing classes provide useful examples.

* **DefaultNativeArgumentDefinitionOverride**.  Inherits NativeArgumentDefinitionOverride.  Default parameter settings if none specified.  Applies Convert.ChangeType as necessary to convert the parameter type on the interface to the specified input type.  In the implicit usage, the input type is either unchanged from the interface, or set to the input type specified in the NativeDelegateDefinitionOverride.

* **DefaultNativeReturnDefinitionOverride**.  Inherits NativeReturnDefinitionOverride.  Default return value settings if none specified.  Applies Convert.ChangeType as necessary to convert the expected output type to the return type on the interface.  In the implicit usage, the output type is either unchanged from the interface, or set to the output type specified in the NativeDelegateDefinitionOverride.

* **NativeArgumentAsStringPointer**.  Inherits NativeArgumentDefinitionOverride.  Assigns strings to IntPtr before passing the pointer to the native delegate.

* **NativeReturnsStringPointer**.  Inherits NativeReturnDefinitionOverride.  Expects IntPtr back from the delegate and marshals a string out of it.

* **NativeArgumentAsStructPointer**.  Inherits NativeArgumentDefinitionOverride.  Assigns value types to IntPtr before passing the pointer to the native delegate.

* **NativeReturnsStructPointer**.  Inherits NativeReturnDefinitionOverride.  Expects IntPtr back from the delegate and marshals a value type out of it.

**ANOTHER NOTE ABOUT ATTRIBUTES, AND ABOUT KNOWING WHEN YOU'RE BEATEN**

After experimenting with various techniques, I have come to the conclusion that it's impossible for me to fulfill all of your automatically generated delegate needs all of the time.  I have therefore added an attribute option which allows you to explicitly specify the delegate you want to use, in scenarios where the generated one won't cut it, or you just think it's easier.

I don't really like it, but it's still a damn sight quicker than doing all the boilerplate stuff I talked about at the beginning of the readme.

Usage:

```
#!c#

// Decorate this with all the shadazzle you know and love - MarshalAs, UnmanagedFunctionPointer, etc.
public delegate int ExplicitAddDelegate(int x, int y);

public interface INativeCalculator
{
    [NativeDelegateDefinitionOverride(ExplicitDelegateType = typeof(ExplicitAddDelegate))]
    int add(int x, int y);
    int subtract(int x, int y);
    int divide(int x, int y);
    int multiply(int x, int y);
}
```

**EXTENSION POINTS**

Most of the usage and examples I've given assume a certain default usage, which you don't have to follow.  I'll now explain some other options.

* **You don't have to use Linux**.  Of course, it's hard to believe that there are Microsoft .NET developers in the world who use Microsoft Windows, but I've heard that there are one or two out there.  I'm currently unable to adequately test my code on an OS other than Linux.  However, to use this code on a different OS, you just need to supply your own INativeLibraryLoader.  I've included an implementation for Windows and an implementation for OSX, but they are not as well-tested as the Linux version.  If you need to roll your own, hopefully the existing implementations provide enough of a guide.

* **You don't have to use Ninject**.  Ninject is my DI container of choice, and the Sws.Spinvoke.Ninject library is the easiest way to wire everything up.  However, in case you don't want to use this, you have a couple of options.  Firstly, if you can track through the Ninject modules, you can infer some poor man's DI, and wire everything up yourself.  Secondly, I've added facades for the core (Sws.Spinvoke.Core.Facade) and the interception (Sws.Spinvoke.Interception.Facade) libraries, which should make life a bit easier.  Complete Ninject-free proxy generation can be done as follows:

```
#!c#

// Build the core facade.
using (var coreFacade = new SpinvokeCoreFacade.Builder(new LinuxNativeLibraryLoader()).Build())
{
	// Build the interception facade.
	var interceptionFacade = new SpinvokeInterceptionFacade.Builder().Build();

	// Create an interceptor for the library.
	var interceptor = interceptionFacade.NativeDelegateInterceptorFactory.CreateInterceptor(
					new NativeDelegateInterceptorContext(
						"libMyLibrary.so",
						CallingConvention.Cdecl,
						coreFacade.NativeDelegateResolver));

	// Build a dynamic proxy (here using Castle DynamicProxy).

	var proxyGenerator = new Castle.DynamicProxy.ProxyGenerator ();

	var proxy = proxyGenerator.CreateInterfaceProxyWithoutTarget<IMyLibraryInterface> (
		new Sws.Spinvoke.Interception.DynamicProxy.SpinvokeInterceptor (interceptor));

	// Invoke it.

	var result = proxy.nativeFunction();
}

```

* **You don't have to use Castle DynamicProxy.**  Instead of using Sws.Spinvoke.Interception.DynamicProxy.SpinvokeInterceptor, you can write an interceptor adapter for whatever proxy generator you want to use instead, and use that directly.  If you still want to use the Ninject extension methods, you can provide your own implementation of Sws.Spinvoke.Interception.IProxyGenerator, and pass this to the SpinvokeNinjectExtensionsConfiguration.Configure method.

* **You don't have to use interception at all.**  I have deliberately left the interception code out of the core.  If you want to use the core directly, the main entry point is INativeDelegateResolver (which you can get an instance of through the facade as shown above, or through the Ninject module).  This lets you resolve native delegates provided that you can supply NativeDelegateDefinitions which describe them.  I have also added an alternative wrapper for this, which lets you generate ad-hoc lambda expressions for calling native code.  You get to this through INativeExpressionBuilder (also available through the core facade):

```
#!c#

// Facade build.
var facade = new SpinvokeCoreFacade.Builder (
	new LinuxNativeLibraryLoader()).Build();

// Get the expression, compile it, and invoke it.
var nativeExpressionBuilder = facade.NativeExpressionBuilder;

var nativeExpression = nativeExpressionBuilder.BuildNativeExpression<Func<int, int, int>> (
	             "libMyLibrary.so",
	             "nativefunction",
	             CallingConvention.Cdecl);

var nativeFunc = nativeExpression.Compile ();

var result = nativeFunc (4, 5);

```

* **You don't have to use the default implementations of anything**.  If you really want to, you can use poor man's DI to wire everything up yourself, using the Ninject modules as a guide.  Alternatively, the facades have builders to allow configuration of dependencies.  You should be able to swap out any component by chaining the With... builder methods prior to calling the Build() method.  This will not expose the full dependency tree structure to you; however, most of the interfaces are fairly self-explanatory.

**HOW IT WORKS!**

In case you're incredibly nerdy, or you've tried to use my code and found some irritating problem, I will now attempt a coherent explanation of how Sws.Spinvoke works.

Firstly, the projects:

* **Sws.Spinvoke.Core**: This is the core library.  In a nutshell, it includes everything you need to generate a delegate for native code, given a NativeDelegateDefinition.  The standard entry point to this functionality is INativeDelegateResolver, which has Resolve and Release methods.  (Release can be used to allow a library to be unloaded when you're done with it.)

* **Sws.Spinvoke.Interception**: This is the interception library.  Everything here revolves around NativeDelegateInterceptor, which has the job of intercepting method calls, getting together a NativeDelegateDefinition, calling INativeDelegateResolver.Resolve, and then invoking the delegate.

* **Sws.Spinvoke.Interception.DynamicProxy**: This library ties the interception library up to Castle DynamicProxy (you can provide your own implementation if you wish).  There are two modes of operation: use SpinvokeInterceptor to adapt a Spinvoke interceptor to a Castle DynamicProxy interceptor (which you can then use in conjunction with DynamicProxy to create native code proxies), or use ProxyGenerator to adapt a Castle DynamicProxy proxy generator to the Spinvoke interception library's IProxyGenerator interface (which you can use to configure the Ninject library).

* **Sws.Spinvoke.Linux**: The Core code is dependent upon an INativeLibraryLoader interface, the implementation of which is platform-specific.  This is a Linux implementation of the interface.

* **Sws.Spinvoke.Windows**: As above, except it's a Windows implementation.

* **Sws.Spinvoke.OSX**: As above, except it's an OSX implementation.

* **Sws.Spinvoke.Ninject**: This is Ninject-specific code.  The primary entry point is the ToNative extension method, which binds an interface to a native code wrapper using the other libraries.  It uses SpinvokeModule, which you can also use directly if you want to use Sws.Spinvoke.Core without interception.

* **Sws.Spinvoke.Core.Facade**: A facade into Sws.Spinvoke.Core, which saves you having to wire up your own dependencies if you're not using Sws.Spinvoke.Ninject.

* **Sws.Spinvoke.Interception.Facade**: A facade into Sws.Spinvoke.Interception, which saves you having to wire up your own dependencies if you're not using Sws.Spinvoke.Ninject.

Secondly, here's a complete guide to what happens when you use the Ninject ToNative extension method:

Configuration:

1. When you call SpinvokeNinjectExtensionsConfiguration.Configure, the INativeLibraryLoader and IProxyGenerator implementations you supply (e.g. from Sws.Spinvoke.Linux and Sws.Spinvoke.Interception.DynamicProxy) are used to set up the ToNative method.  The native library loader is used in conjunction with the SpinvokeModule to wire up an INativeDelegateResolver.
2. SpinvokeModule specifies that the INativeDelegateResolver is an instance of Sws.Spinvoke.Core.DefaultNativeDelegateResolver.
3. DefaultNativeDelegateResolver has three arguments: An INativeLibraryLoader (which you supplied), an IDelegateTypeProvider, and an INativeDelegateProvider.  These objects can be used together to get a function pointer for a native function, create a delegate type, and combine the two to instantiate a delegate.
4. IDelegateTypeProvider has the job of getting a delegate type given a delegate signature.  It is bound to a DynamicAssemblyDelegateTypeProvider instance, through a wrapper which handles caching.  DynamicAssemblyDelegateTypeProvider uses Reflection.Emit to generate a type based on the delegate signature, which is stored in a dynamically generated assembly.
5. INativeDelegateProvider has the job of instantiating a native delegate given a delegate type and a function pointer.  It is bound to FrameworkNativeDelegateTypeProvider, which just uses Marshal.GetDelegateForFunctionPointer.

Binding to a native proxy:

1. When you call the ToNative method with a library name, a custom Ninject Provider is created which will handle the proxy resolution.
2. When you call WithCallingConvention, the calling convention you supply is registered with the Provider.  Otherwise, the default is Winapi.

Resolving the native proxy:

1. When you call Get and the provider's CreateInstance method is called, an Sws.Spinvoke.Interception.NativeDelegateInterceptor is instantiated.
2. The NativeDelegateInterceptor has three arguments: The library name (passed through from the ToNative call), the calling convention, and the INativeDelegateResolver which was resolved earlier.
3. The CreateInstance method then passes the interceptor to the proxy generator, which gives you a proxy into the native code.

Using the native proxy:

1. When you call one of the methods of the generated proxy, the invocation is intercepted by NativeDelegateInterceptor.
2. NativeDelegateInterceptor uses the MethodInfo to create a native delegate mapping.  This factors in the attributes discussed above, and ultimately provides all of the information required to pass through to native code.
3. Each argument in the invocation is processed through its associated IArgumentPreprocessor (which may have come from an attribute, or it might just be the default, which uses System.Convert to change the type of the argument to the required input type, if it is different).  If the IArgumentPreprocessor cannot handle the argument (for example, if you're using StringToPointer and the argument is not a string), an InvalidOperationException is thrown.
4. The input types from the native delegate mapping are then checked against the processed arguments.  If the processed arguments do not match the input types, the input type is changed to match the argument (in the hope that .NET can deal with it lower down).
5. The information is then put together into a NativeDelegateDefinition, as expected by the Core library.
6. The native delegate resolver (i.e. DefaultNativeDelegateResolver) is then called to resolve a delegate based on the NativeDelegateDefinition.
7. DefaultNativeDelegateResolver loads the library (if it is not already loaded) using its INativeLibraryLoader.
8. It then checks to see if it already has a delegate cached for this definition.  If so, this delegate is returned.
9. If there is no delegate cached, it gets a function pointer for the function using INativeLibraryLoader.
10. If no ExplicitDelegateType has been specified, it then goes to the delegate type provider (DynamicAssemblyDelegateTypeProvider, via a cache to improve performance) to build a type for the delegate.
11. As discussed earlier, DynamicAssemblyDelegateTypeProvider assembles a type for the delegate using Reflection.Emit.
12. The delegate type and the function pointer are then passed to the native delegate provider (FrameworkNativeDelegateProvider) to create a delegate instance for the native code.  As discussed earlier, this just uses Marshal.GetDelegateForFunctionPointer.
13. The delegate instance is cached and returned to the interceptor.
14. The interceptor then invokes the delegate with the processed arguments.  If all goes well, this calls into the native code, which does its stuff and returns a value of the expected output type.
15. The return value is then put through an IReturnPostprocessor (which may have come from an attribute, or it might just be the default, which uses ChangeType) to convert the value to the return value required by the method.  This is then set as the return value for the intercepted call.
16. Once the process is complete, each IArgumentPreprocessor has its ReleaseProcessedInput method called with the processed argument, in case it wants to do any tidying up.

**JULY 2015 UPDATE**

I have finally got around to doing a bit more testing on Windows. I won't commit a full Visual Studio port yet as I haven't decided exactly what that will look like, but I've made the following discoveries/tweaks:

1. You have to be careful if you use the argument/return string pointer attributes. Under the hood they use StringToHGlobalAuto and PtrToStringAuto, which on Windows 8 is Unicode. Therefore, to use my Windows test native library (which I created with MinGW) I had to create new attributes which used StringToHGlobalAnsi and PtrToStringAnsi. I've made some modifications to make this a bit easier, although it's non-trivial. You need to inherit from the following four classes: StringToPointerArgumentPreprocessor (override StringToPointer), NativeArgumentDefinitionOverrideAttribute (to wrap the argument preprocessor in an attribute), PointerToStringReturnPostprocessor (override PtrToString), and NativeReturnDefinitionOverrideAttribute (to wrap the return postprocessor in an attribute). Personally I think you're better off creating an explicit delegate type (see below) if you really need to get into the nuts and bolts of this.

2. The work-in-progress garbage collection for pointers which are hidden by the interception process couldn't free memory allocated by the MinGW-compiled library, which was causing horrible crashes. To be honest that's because allowing any setting other than DoNotDestroy on a pointer coming back from native code is kind of evil - we shouldn't be attempting to free memory allocated elsewhere, especially since we don't know where it's allocated (on Mono it just happens to normally be the right place). In order to make this functionality a bit more usable, I've made various changes to facilitate overriding of the default memory management mechanism.

3. There were a couple of compatibility issues compiling the code for .NET proper rather than Mono. These were to do with a generic Marshal.PtrToStructure overload which was available in Mono but not .NET 4.5 (introduced in 4.5.1 I think), and Marshal.GetFunctionPointerForDelegate supporting generic delegate types in Mono. These issues are fixed.

Both of the first two issues relate to a fairly minor feature that I'm contemplating the existence of. Is an extra layer of pointer stuff really necessary? Most of the time, the standard P/Invoke behaviour for strings and structs should do you just fine, and in the cases where it doesn't, you'll probably need to either implement your own pre- and post-processing attributes, or just forget about using this library altogether.

Just in case, however: The changes I have made to allow the freeing of pointers to be more flexible are as follows:

1. All classes which previously attempted to free pointers now expect a PointerMemoryManager to be injected. The default can be accessed through InterceptionAllocatedMemoryManager.PointerMemoryManager, NativeReturnDefinitionOverrideAttribute.DefaultPointerMemoryManager, or NativeArgumentDefinitionOverrideAttribute.DefaultPointerMemoryManager. This is wrapped by the static InterceptionAllocatedMemoryManager calls, so in general you should continue to use this. However, you can also inherit from PointerMemoryManager and change the behaviour however you want.

2. Alternatively, the PointerMemoryManager also allows an optional argument which explicitly specifies how a pointer is to be freed. This is probably the preferred approach. If, for example, you have a situation where the library you are using has a customised function for freeing a returned pointer once you've processed the data, you can create your own NativeReturnDefinitionOverrideAttribute, and in the IReturnPostprocessor implementation, pass a call to this function to the PointerMemoryManager to ensure that the pointer is freed. (If you implement the new interface IContextualReturnPostprocessor instead, you can capture context relating to the interception call, in case it's useful.)

Separately, I came back to Mono to find a bizarre bug killing the unit tests dead, which definitely wasn't happening last time I looked. I've fixed this with a horrible workaround for now (see commit labelled "Horrible workaround for horrible Moq problem.").

**NOVEMBER 2015 UPDATE**

Since I now have a bit more access to the relevant operating systems, I have generalised the integration tests and added Windows/OSX support. This now means that even if you are using MonoDevelop on Linux (which is the home for this solution), you will have some test failures, because the Windows and OSX tests will not work. You can resolve this by unloading the failing test projects. On the plus side, the code is now entirely testable within Visual Studio on Windows (which, considering this is a .NET solution, is a big bonus).

I will try to configure the tests to use compile-time flags in due course, so that you don't have to unload any projects. I am also considering writing some sort of platform-detecting bootstrapper, so that e.g. you don't have to manually select the right INativeLibraryLoader for your OS. I don't know how useful this will be, since if you're calling native code you're going to have cross-platform issues anyway, but I suppose it's one less thing to worry about.

**AUGUST 2016 UPDATE**

I recently tried to use this library with Mono running inside a Docker container on a Raspberry Pi. It *almost* worked out of the box, but I had a problem because the Docker image only included an explicitly versioned libdl.so.2 library, and did not include a symlink libdl.so. This library is required by the LinuxNativeLibraryLoader to dynamically load libraries; and the problem manifests in a DllNotFoundException for libdl.so. As far as I can tell, Mono does not look for the explicitly versioned file when resolving the DllImport for libdl. If you have a similar problem, you can resolve it as follows:

1. Find libdl on the target system (Google can explain how to do this). If you can't find it, you may have to install something.
2. Add dllmap configuration for the Sws.Spinvoke.Linux library (Google can also explain this one), pointing "libdl.so" to the version which is available, e.g. "libdl.so.2".